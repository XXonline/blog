<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[使用正则获取当前URL中的参数]]></title>
      <url>%2F2017%2F06%2F09%2F%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8DURL%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%2F</url>
      <content type="text"><![CDATA[使用场景：在前台，当需要通过当前url这个的参数处理一些逻辑的时候，可以使用此方法。 函数如下：123456function getQueryString(name) &#123; var reg = new RegExp("(^|&amp;)" + name + "=([^&amp;]*)(&amp;|$)", "i"); var r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null;&#125; 使用方法：name-参数名称为字符串形式。若当前链接后面的参数为?name=itonline&amp;sex=gg&amp;age=18，则获取name参数值的调用方式为：getQueryString(&quot;name&quot;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS中innerHTML、outerHTML、innerText、outerText的用法与区别]]></title>
      <url>%2F2017%2F05%2F03%2FJS%E4%B8%ADinnerHTML%E3%80%81outerHTML%E3%80%81innerText%E3%80%81outerText%E7%9A%84%E7%94%A8%E6%B3%95%E4%B8%8E%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[–转自http://blog.163.com/yw_0721/blog/static/7164579720102932157759/ 在JS中可以使用： innerHTML:也就是从对象的起始位置到终止位置的全部内容,包括Html标签。 innerText:从起始位置到终止位置的内容, 但它去除Html标签。 outerHTML:除了包含innerHTML的全部内容外, 还包含对象标签本身。 outerText:设置(包括标签)或获取(不包括标签)对象的文本 。示例：123&lt;div id="test"&gt; &lt;span style="color:red"&gt;test1&lt;/span&gt; test2&lt;/div&gt; 123&lt;a href="javascript:alert(test.innerHTML)"&gt;innerHTML内容&lt;/a&gt;&lt;a href="javascript:alert(test.innerText)"&gt;innerText内容&lt;/a&gt;&lt;a href="javascript:alert(test.outerHTML)"&gt;outerHTML内容&lt;/a&gt; ###特别说明：innerHTML是符合W3C标准的属性，而innerText只适用于IE浏览器，因此，尽可能地去使用innerHTML，而少用innerText，如果要输出不含HTML标签的内容，可以使用innerHTML取得包含HTML标签的内容后，再用正则表达式去除HTML标签，下面是一个简单的符合W3C标准的示例：1&lt;a href="javascript:alert(document.getElementById('test').innerHTML.replace(/&lt;.+?&gt;/gim,''))"&gt;无HTML,符合W3C标准&lt;/a&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[break-continue-return之间的区别]]></title>
      <url>%2F2017%2F04%2F07%2Fbreak-continue-return%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[breakbreak 语句用于退出 switch 语句或循环语句(for, for … in, while, do … while)。当 break 语句用于 switch 语句中时，会跳出 switch 代码块(终止执行其代码)。如： 12345678910111213141516171819202122232425var day;switch (new Date().getDay()) &#123; case 0: day = "Sunday"; break; case 1: day = "Monday"; break; case 2: day = "Tuesday"; break; case 3: day = "Wednesday"; break; case 4: day = "Thursday"; break; case 5: day = "Friday"; break; case 6: day = "Saturday"; break;&#125;console.log(day); 当 break 语句用于for循环语句时，(跳出整个循环体)会终止执行循环，并执行循环后代码(如果有的话)。如： 12345678910(function ()&#123; var iSum = 0; for(var i = 1;i&lt;101;i++)&#123; if(i == 5)&#123; break; &#125; iSum +=i; &#125; console.log(iSum); //10&#125;()) continuecontinue 跳过当前条件的循环(用于跳过循环中的一个迭代，并继续执行循环中的下一个迭代)。continue 与 break语句的区别是， break 是结束整个循环体， continue 是结束单次循环。 注意： continue 语句（不带标签引用），只能用在循环或 switch 中。 12345678910111213141516171819202122//在 while 循环中var text = "";var i = 0;while (i &lt; 5) &#123; i++; if (i == 3) &#123; continue; &#125;console.log(i); //1,2,4,5&#125;//在 for 循环中(function ()&#123; var iSum = 0; for(var i = 1;i&lt;101;i++)&#123; if(i == 5)&#123; continue; &#125; iSum +=i; &#125; console.log(iSum); //5045&#125;()) returnreturn表示(结束整个方法体)终止函数的执行并返回函数的值。1234567891011121314151617181920212223242526272829//用法1(function ()&#123; var iSum = 0; for(var i = 1;i&lt;101;i++)&#123; if(i == 5)&#123; return; &#125; iSum +=i; &#125; console.log(iSum); //当i==5时，结束（return）了整个方法体，所以此时没有执行这行代码&#125;())//用法2(function ()&#123; var iSum = 0; for(var i = 1;i&lt;101;i++)&#123; if(i == 5)&#123; //return; i = A(i); &#125; iSum +=i; &#125; console.log(iSum); //5015,i 跳过了5，6，7，8，9，此时的i设为了10&#125;())function A(i)&#123; i+=5; return i; //i可选(非必填)。指定返回的函数值。如果忽略，A(i)函数将返回 undefined&#125; 总结：break:跳出整个循环体continue:跳过当前条件的循环return：结束当前方法体]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS中typeof与instanceof的区别]]></title>
      <url>%2F2017%2F04%2F07%2FJS%E4%B8%ADtypeof%E4%B8%8Einstanceof%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[JavaScript 中 typeof 和 instanceof 常用来判断一个变量是否为空，或者是什么类型的。区别：typeof typeof 是一个一元运算，放在一个运算数之前，运算数可以是任意类型。 它返回值是一个字符串，该字符串说明运算数的类型。typeof 一般只能返回如下几个结果： number,boolean,string,function,object,undefined。我们可以使用 typeof 来获取一个变量是否存在，如 if(typeof a!=”undefined”){alert(“ok”)}，而不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错，对于 Array,Null 等特殊对象使用 typeof 一律返回 object，这正是 typeof 的局限性。 instanceof instanceof 用于判断一个变量是否某个对象的实例，如: 12345678910111213141516171819202122232425262728//判断a是否是Array的实例var a = new Array();console.log(a instanceof Array); //trueconsole.log(window instanceof Object); //true//所以，这里的 instanceof 测试的 object 是指 js 语法中的 object，不是指 dom 模型对象。console.log(a instanceof object); //true, 因为 Array 是 object 的子类//判断a是否是test的实例function test()&#123;&#125;;var a=new test();console.log(a instanceof test); //true // 判断 foo 是否是 Foo 类的实例 , 并且是否是其父类型的实例 function Aoo()&#123;&#125; function Foo()&#123;&#125; Foo.prototype = new Aoo();//JavaScript 原型继承 var foo = new Foo(); console.log(foo instanceof Foo)//true console.log(foo instanceof Aoo)//true //instanceof 复杂用法 console.log(Object instanceof Object);//true console.log(Function instanceof Function);//true console.log(Number instanceof Number);//false console.log(String instanceof String);//false console.log(Function instanceof Object);//true console.log(Foo instanceof Function);//true console.log(Foo instanceof Foo);//false 未完待续…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NodeJS 文件(夹)压缩/解压(zip/unzip)]]></title>
      <url>%2F2017%2F03%2F23%2FNodeJS-%E6%96%87%E4%BB%B6-%E5%A4%B9-%E5%8E%8B%E7%BC%A9-%E8%A7%A3%E5%8E%8B-zip-unzip%2F</url>
      <content type="text"><![CDATA[我使用的比较靠谱的,也比较简单.其中archiver很强大支持zip格式tar格式,只需要提供路径就可以压缩已存在的文件夹. 压缩：123456789101112131415var fs = require('fs');var archiver = require('archiver');var output = fs.createWriteStream('archiver-unzip.zip');var archive = archiver('zip');archive.on('error', function(err)&#123; throw err; &#125;);archive.pipe(output);archive.bulk([ &#123; src: ['archiver/**']&#125;]);archive.finalize(); 解压:1234var fs = require("fs");var unzip = require("unzip");fs.createReadStream('archiver-unzip.zip').pipe(unzip.Extract(&#123; path: 'unarchive' &#125;));]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webstorm下调试node提示：v8debug is not defined]]></title>
      <url>%2F2017%2F03%2F23%2Fwebstorm%E4%B8%8B%E8%B0%83%E8%AF%95node%E6%8F%90%E7%A4%BA%EF%BC%9Av8debug-is-not-defined%2F</url>
      <content type="text"><![CDATA[解决步骤：Run/Debug configurations -&gt;configuration-&gt;Node parameters: –expose_debug_as=v8debug]]></content>
    </entry>

    
  
  
</search>
